<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Crypto Chart Analyzer with Multi-Timeframe Confluence Signals (Local Time)</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://unpkg.com/lightweight-charts@4.0.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        .stochastic-legend {
            position: absolute;
            right: 20px;
            bottom: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 0;
            max-width: 200px;
        }
        .stochastic-legend-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
        }
        .stochastic-legend-color {
            width: 12px;
            height: 12px;
            margin-right: 6px;
            border-radius: 2px;
        }
        .alert-container {
            max-height: 350px;
            overflow-y: auto;
        }
        .signal-indicator {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .confluence-signal {
            border-left: 4px solid #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
        }
        .long-signal {
            border-left: 4px solid #10b981;
            background: rgba(16, 185, 129, 0.1);
        }
        .short-signal {
            border-left: 4px solid #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }
        .timeframe-alert {
            border-left: 4px solid #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }
        /* PDF optimization */
        body {
            print-color-adjust: exact;
            -webkit-print-color-adjust: exact;
        }
        @media print {
            body { margin: 0; }
            .container { max-width: none; margin: 0; padding: 10px; }
            .alert-container { max-height: none; overflow: visible; }
        }
        .timeframe-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 1px;
            display: inline-block;
            min-width: 35px;
            text-align: center;
        }
        .tf-loading { background: #d1d5db; color: #374151; }
        .tf-oversold { background: #dcfce7; color: #166534; }
        .tf-overbought { background: #fecaca; color: #991b1b; }
        .tf-neutral { background: #f3f4f6; color: #6b7280; }
        .alert-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 8px;
        }
        .alert-new { background: #ef4444; color: white; }
        .alert-stored { background: #6b7280; color: white; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6">
            <div class="flex items-center justify-between mb-6">
                <h1 class="text-3xl font-bold text-gray-800">
                    <i class="fas fa-chart-line text-blue-600 mr-2"></i>
                    Multi-Timeframe Confluence Analyzer (Local Time)
                </h1>
                <div class="flex items-center space-x-4">
                    <select id="crypto-selector" class="bg-white border border-gray-300 rounded-lg px-4 py-2 focus:ring-2 focus:ring-blue-500">
                        <option value="BTCUSDT">Bitcoin (BTC/USDT)</option>
                        <option value="ETHUSDT">Ethereum (ETH/USDT)</option>
                        <option value="SOLUSDT">Solana (SOL/USDT)</option>
                        <option value="BNBUSDT">Binance Coin (BNB/USDT)</option>
                        <option value="ADAUSDT">Cardano (ADA/USDT)</option>
                        <option value="XRPUSDT">XRP (XRP/USDT)</option>
                        <option value="LINKUSDT">Chainlink (LINK/USDT)</option>
                        <option value="UNIUSDT">Uniswap (UNI/USDT)</option>
                    </select>
                    <button id="clear-alerts-btn" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg transition-colors">
                        <i class="fas fa-trash mr-1"></i>Clear Alerts
                    </button>
                </div>
            </div>

            <!-- Main Timeframe Selector -->
            <div class="mb-4">
                <h3 class="text-lg font-semibold mb-2">Display Timeframe</h3>
                <div id="timeframe-selector" class="flex flex-wrap gap-2">
                    <button class="timeframe-btn px-4 py-2 bg-gray-200 hover:bg-blue-500 hover:text-white rounded-lg transition-colors" data-tf="1m">1M</button>
                    <button class="timeframe-btn px-4 py-2 bg-gray-200 hover:bg-blue-500 hover:text-white rounded-lg transition-colors" data-tf="5m">5M</button>
                    <button class="timeframe-btn px-4 py-2 bg-gray-200 hover:bg-blue-500 hover:text-white rounded-lg transition-colors" data-tf="10m">10M</button>
                    <button class="timeframe-btn px-4 py-2 bg-gray-200 hover:bg-blue-500 hover:text-white rounded-lg transition-colors" data-tf="15m">15M</button>
                    <button class="timeframe-btn px-4 py-2 bg-gray-200 hover:bg-blue-500 hover:text-white rounded-lg transition-colors" data-tf="30m">30M</button>
                    <button class="timeframe-btn px-4 py-2 bg-blue-500 text-white rounded-lg active" data-tf="1h">1H</button>
                </div>
            </div>

            <!-- Multi-Timeframe Status -->
            <div class="mb-4 bg-gray-50 p-4 rounded-lg">
                <h3 class="text-lg font-semibold mb-3">Multi-Timeframe Analysis Status</h3>
                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
                    <div class="text-center">
                        <h4 class="font-medium text-sm mb-2">1 Minute</h4>
                        <div class="space-y-1">
                            <div class="timeframe-status tf-loading" id="tf-1m-fast">Fast: --</div>
                            <div class="timeframe-status tf-loading" id="tf-1m-medium">Med: --</div>
                            <div class="timeframe-status tf-loading" id="tf-1m-slow">Slow: --</div>
                            <div class="timeframe-status tf-loading" id="tf-1m-full">Full: --</div>
                        </div>
                    </div>
                    <div class="text-center">
                        <h4 class="font-medium text-sm mb-2">5 Minutes</h4>
                        <div class="space-y-1">
                            <div class="timeframe-status tf-loading" id="tf-5m-fast">Fast: --</div>
                            <div class="timeframe-status tf-loading" id="tf-5m-medium">Med: --</div>
                            <div class="timeframe-status tf-loading" id="tf-5m-slow">Slow: --</div>
                            <div class="timeframe-status tf-loading" id="tf-5m-full">Full: --</div>
                        </div>
                    </div>
                    <div class="text-center">
                        <h4 class="font-medium text-sm mb-2">10 Minutes</h4>
                        <div class="space-y-1">
                            <div class="timeframe-status tf-loading" id="tf-10m-fast">Fast: --</div>
                            <div class="timeframe-status tf-loading" id="tf-10m-medium">Med: --</div>
                            <div class="timeframe-status tf-loading" id="tf-10m-slow">Slow: --</div>
                            <div class="timeframe-status tf-loading" id="tf-10m-full">Full: --</div>
                        </div>
                    </div>
                    <div class="text-center">
                        <h4 class="font-medium text-sm mb-2">15 Minutes</h4>
                        <div class="space-y-1">
                            <div class="timeframe-status tf-loading" id="tf-15m-fast">Fast: --</div>
                            <div class="timeframe-status tf-loading" id="tf-15m-medium">Med: --</div>
                            <div class="timeframe-status tf-loading" id="tf-15m-slow">Slow: --</div>
                            <div class="timeframe-status tf-loading" id="tf-15m-full">Full: --</div>
                        </div>
                    </div>
                    <div class="text-center">
                        <h4 class="font-medium text-sm mb-2">30 Minutes</h4>
                        <div class="space-y-1">
                            <div class="timeframe-status tf-loading" id="tf-30m-fast">Fast: --</div>
                            <div class="timeframe-status tf-loading" id="tf-30m-medium">Med: --</div>
                            <div class="timeframe-status tf-loading" id="tf-30m-slow">Slow: --</div>
                            <div class="timeframe-status tf-loading" id="tf-30m-full">Full: --</div>
                        </div>
                    </div>
                    <div class="text-center">
                        <h4 class="font-medium text-sm mb-2">1 Hour</h4>
                        <div class="space-y-1">
                            <div class="timeframe-status tf-loading" id="tf-1h-fast">Fast: --</div>
                            <div class="timeframe-status tf-loading" id="tf-1h-medium">Med: --</div>
                            <div class="timeframe-status tf-loading" id="tf-1h-slow">Slow: --</div>
                            <div class="timeframe-status tf-loading" id="tf-1h-full">Full: --</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Indicator Controls -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="text-lg font-semibold mb-3">Stochastic Indicators</h3>
                    <div class="space-y-2">
                        <label class="flex items-center">
                            <input type="checkbox" id="stoch-fast-10-3" checked class="mr-2">
                            <span class="text-sm">Fast (10,3) - Red</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="stoch-medium-14-3" checked class="mr-2">
                            <span class="text-sm">Medium (14,3) - Green</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="stoch-slow-40-4" checked class="mr-2">
                            <span class="text-sm">Slow (40,4) - Blue</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="stoch-full-60-3-1" checked class="mr-2">
                            <span class="text-sm">Full (60,3,1) - Purple</span>
                        </label>
                    </div>
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="text-lg font-semibold mb-3">EMA Lines</h3>
                    <div class="flex flex-wrap gap-2">
                        <button class="toggle-btn ema-btn px-3 py-1 bg-orange-500 text-white rounded active" data-ema="20">20 EMA</button>
                        <button class="toggle-btn ema-btn px-3 py-1 bg-gray-300 rounded" data-ema="50">50 EMA</button>
                        <button class="toggle-btn ema-btn px-3 py-1 bg-gray-300 rounded" data-ema="100">100 EMA</button>
                        <button class="toggle-btn ema-btn px-3 py-1 bg-gray-300 rounded" data-ema="200">200 EMA</button>
                    </div>
                </div>

                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="text-lg font-semibold mb-3">Chart Type</h3>
                    <div class="flex gap-2">
                        <button id="regular-candles" class="chart-type-btn px-3 py-1 bg-blue-500 text-white rounded active">Regular</button>
                        <button id="heikin-ashi" class="chart-type-btn px-3 py-1 bg-gray-300 rounded">Heikin Ashi</button>
                    </div>
                </div>
            </div>

            <!-- Split Charts Container -->
            <div class="space-y-4 mb-6">
                <!-- Price Chart -->
                <div class="relative">
                    <h3 class="text-lg font-semibold mb-2">Price Chart (Local Time)</h3>
                    <div id="price-chart-container" class="w-full border rounded-lg" style="height: 400px;">
                        <button id="restore-price-chart-btn" class="absolute top-2 left-2 bg-white bg-opacity-90 hover:bg-opacity-100 px-3 py-1 rounded-lg text-sm z-10 transition-all">
                            <i class="fas fa-home mr-1"></i>Reset View
                        </button>
                    </div>
                </div>

                <!-- Stochastic Chart -->
                <div class="relative">
                    <h3 class="text-lg font-semibold mb-2">Stochastic Oscillator with Background Zones (Local Time)</h3>
                    <div id="stochastic-chart-container" class="w-full border rounded-lg" style="height: 250px;">
                        <button id="restore-stochastic-chart-btn" class="absolute top-2 left-2 bg-white bg-opacity-90 hover:bg-opacity-100 px-3 py-1 rounded-lg text-sm z-10 transition-all">
                            <i class="fas fa-home mr-1"></i>Reset View
                        </button>
                    </div>
                    <div id="stochastic-legend" class="stochastic-legend"></div>
                </div>
            </div>

            <!-- Trading Signals Dashboard -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Confluence Signal Conditions -->
                <div class="bg-white border rounded-lg p-4">
                    <h3 class="text-xl font-semibold mb-4 flex items-center">
                        <i class="fas fa-layer-group text-purple-600 mr-2"></i>
                        Confluence Trading Signals
                    </h3>
                    
                    <!-- Basic Signals -->
                    <div class="mb-4 p-3 bg-blue-50 rounded-lg">
                        <h4 class="font-semibold text-blue-800 mb-2 flex items-center">
                            <i class="fas fa-signal mr-2"></i>Basic Signals
                        </h4>
                        <div class="space-y-1 text-sm">
                            <div class="flex items-center" id="basic-long-condition">
                                <i class="fas fa-circle text-gray-300 mr-2 condition-icon"></i>
                                <span>Long: All bands â‰¤ 15 (oversold)</span>
                            </div>
                            <div class="flex items-center" id="basic-short-condition">
                                <i class="fas fa-circle text-gray-300 mr-2 condition-icon"></i>
                                <span>Short: All bands â‰¥ 90 (overbought)</span>
                            </div>
                        </div>
                    </div>

                    <!-- Confluence Levels -->
                    <div class="space-y-3">
                        <div class="p-3 bg-purple-50 rounded-lg">
                            <h4 class="font-semibold text-purple-800 mb-2">Confluence Level 1 (1m + 5m)</h4>
                            <div class="flex items-center" id="confluence-1-condition">
                                <i class="fas fa-circle text-gray-300 mr-2 condition-icon"></i>
                                <span class="text-sm">Both timeframes aligned</span>
                            </div>
                        </div>
                        
                        <div class="p-3 bg-purple-50 rounded-lg">
                            <h4 class="font-semibold text-purple-800 mb-2">Confluence Level 2 (1m + 5m + 10m)</h4>
                            <div class="flex items-center" id="confluence-2-condition">
                                <i class="fas fa-circle text-gray-300 mr-2 condition-icon"></i>
                                <span class="text-sm">Three timeframes aligned</span>
                            </div>
                        </div>
                        
                        <div class="p-3 bg-purple-50 rounded-lg">
                            <h4 class="font-semibold text-purple-800 mb-2">Confluence Level 3 (1m + 5m + 10m + 15m)</h4>
                            <div class="flex items-center" id="confluence-3-condition">
                                <i class="fas fa-circle text-gray-300 mr-2 condition-icon"></i>
                                <span class="text-sm">Four timeframes aligned</span>
                            </div>
                        </div>
                        
                        <div class="p-3 bg-purple-50 rounded-lg">
                            <h4 class="font-semibold text-purple-800 mb-2">Confluence Level 4 (1m + 5m + 10m + 15m + 30m)</h4>
                            <div class="flex items-center" id="confluence-4-condition">
                                <i class="fas fa-circle text-gray-300 mr-2 condition-icon"></i>
                                <span class="text-sm">Five timeframes aligned</span>
                            </div>
                        </div>
                        
                        <div class="p-3 bg-purple-50 rounded-lg">
                            <h4 class="font-semibold text-purple-800 mb-2">Confluence Level 5 (All Timeframes)</h4>
                            <div class="flex items-center" id="confluence-5-condition">
                                <i class="fas fa-circle text-gray-300 mr-2 condition-icon"></i>
                                <span class="text-sm">All six timeframes aligned</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Enhanced Alerts Panel -->
                <div class="bg-white border rounded-lg p-4">
                    <h3 class="text-xl font-semibold mb-4 flex items-center">
                        <i class="fas fa-bell text-red-600 mr-2"></i>
                        Live Confluence Alerts
                        <span id="stored-alert-count" class="alert-badge alert-stored ml-2">0 Stored</span>
                    </h3>
                    <div id="alerts-container" class="alert-container space-y-2">
                        <div class="p-3 bg-blue-50 border-l-4 border-blue-500 rounded">
                            <div class="flex items-center">
                                <i class="fas fa-info-circle text-blue-500 mr-2"></i>
                                <span class="text-sm">
                                    [<span id="initial-timestamp"></span>] Multi-timeframe confluence system with alert storage initialized (Local Time)...
                                </span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Current Confluence Status -->
                    <div class="mt-4 p-3 bg-gray-50 rounded-lg">
                        <h4 class="font-semibold mb-2">Current Status</h4>
                        <div class="text-sm space-y-1">
                            <div>Active Confluence Level: <span id="current-confluence-level" class="font-bold">0</span></div>
                            <div>Last Signal: <span id="last-signal-type" class="font-bold">None</span></div>
                            <div>Signal Strength: <span id="signal-strength" class="font-bold">Weak</span></div>
                            <div>Alerts Stored: <span id="alert-count-display" class="font-bold">0/10</span></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Market Information -->
            <div class="mt-6 grid grid-cols-1 md:grid-cols-4 gap-4">
                <div class="bg-gradient-to-r from-blue-500 to-blue-600 text-white p-4 rounded-lg">
                    <h4 class="font-semibold mb-2">Market Trend</h4>
                    <div id="market-trend" class="text-lg">Analyzing...</div>
                </div>
                <div class="bg-gradient-to-r from-purple-500 to-purple-600 text-white p-4 rounded-lg">
                    <h4 class="font-semibold mb-2">Confluence Level</h4>
                    <div id="confluence-display" class="text-lg">0/5</div>
                </div>
                <div class="bg-gradient-to-r from-green-500 to-green-600 text-white p-4 rounded-lg">
                    <h4 class="font-semibold mb-2">Signal Quality</h4>
                    <div id="signal-quality" class="text-lg">Waiting...</div>
                </div>
                <div class="bg-gradient-to-r from-yellow-500 to-yellow-600 text-white p-4 rounded-lg">
                    <h4 class="font-semibold mb-2">Chart Type</h4>
                    <div id="current-chart-type" class="text-lg">Regular</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let priceChart;
        let stochasticChart;
        let candleSeries;
        let stochasticSeries = {};
        let backgroundSeries = {};
        let currentTimeframe = '1h';
        let currentSymbol = 'BTCUSDT';
        let updateInterval;
        let lastAlertTime = 0;
        let isHeikinAshi = false;
        
        // Multi-timeframe data storage
        let multitimeframeData = {
            '1m': { stochastics: {}, lastUpdate: 0 },
            '5m': { stochastics: {}, lastUpdate: 0 },
            '10m': { stochastics: {}, lastUpdate: 0 },
            '15m': { stochastics: {}, lastUpdate: 0 },
            '30m': { stochastics: {}, lastUpdate: 0 },
            '1h': { stochastics: {}, lastUpdate: 0 }
        };
        
        // Alert storage
        let alertHistory = [];
        let timeframeAlertStates = {};
        
        // EMA series
        let emaSeries = {
            '20': null,
            '50': null,
            '100': null,
            '200': null
        };
        
        // Current display data
        let currentCandles = [];
        let currentHeikinAshi = [];
        
        // Stochastic colors and labels
        const stochColors = {
            'fast': { color: '#EF4444', label: 'Fast (10,3)' },
            'medium': { color: '#10B981', label: 'Medium (14,3)' },
            'slow': { color: '#3B82F6', label: 'Slow (40,4)' },
            'full': { color: '#8B5CF6', label: 'Full (60,3,1)' }
        };

        // Timezone handling function
        function convertToLocalTime(utcTimestamp) {
            // The timestamp from Binance is already in UTC milliseconds
            // Convert to local time by creating a new Date object
            // The lightweight-charts library expects Unix timestamp in seconds
            return Math.floor(utcTimestamp / 1000);
        }

        // Local Storage Functions
        function loadStoredAlerts() {
            try {
                const stored = localStorage.getItem('cryptoAnalyzerAlerts');
                if (stored) {
                    alertHistory = JSON.parse(stored);
                    updateAlertCount();
                    displayStoredAlerts();
                }
            } catch (error) {
                console.error('Error loading stored alerts:', error);
                alertHistory = [];
            }
        }

        function saveAlert(alert) {
            alertHistory.unshift(alert); // Add to beginning
            if (alertHistory.length > 10) {
                alertHistory = alertHistory.slice(0, 10); // Keep only last 10
            }
            
            try {
                localStorage.setItem('cryptoAnalyzerAlerts', JSON.stringify(alertHistory));
                updateAlertCount();
            } catch (error) {
                console.error('Error saving alert:', error);
            }
        }

        function clearStoredAlerts() {
            alertHistory = [];
            localStorage.removeItem('cryptoAnalyzerAlerts');
            updateAlertCount();
            
            // Clear alert display except system message
            const alertsContainer = document.getElementById('alerts-container');
            while (alertsContainer.children.length > 1) {
                alertsContainer.removeChild(alertsContainer.children[1]);
            }
        }

        function updateAlertCount() {
            const count = alertHistory.length;
            document.getElementById('stored-alert-count').textContent = `${count} Stored`;
            document.getElementById('alert-count-display').textContent = `${count}/10`;
        }

        function displayStoredAlerts() {
            // Display stored alerts in the UI (most recent first)
            alertHistory.forEach(alert => {
                addAlertToUI(alert.message, alert.type, alert.signalType, alert.timestamp, true);
            });
        }

        function initCharts() {
            const priceContainer = document.getElementById('price-chart-container');
            const stochasticContainer = document.getElementById('stochastic-chart-container');
            
            // Clear containers
            priceContainer.innerHTML = '<button id="restore-price-chart-btn" class="absolute top-2 left-2 bg-white bg-opacity-90 hover:bg-opacity-100 px-3 py-1 rounded-lg text-sm z-10 transition-all"><i class="fas fa-home mr-1"></i>Reset View</button>';
            stochasticContainer.innerHTML = '<button id="restore-stochastic-chart-btn" class="absolute top-2 left-2 bg-white bg-opacity-90 hover:bg-opacity-100 px-3 py-1 rounded-lg text-sm z-10 transition-all"><i class="fas fa-home mr-1"></i>Reset View</button>';

            // Create price chart with local time configuration
            priceChart = LightweightCharts.createChart(priceContainer, {
                layout: {
                    backgroundColor: '#ffffff',
                    textColor: '#333',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
                width: priceContainer.clientWidth,
                height: priceContainer.clientHeight,
                timeScale: {
                    rightOffset: 0,
                    barSpacing: 6,
                    fixLeftEdge: false,
                    fixRightEdge: true,
                    lockVisibleTimeRangeOnResize: true,
                    timeVisible: true,
                    secondsVisible: true,
                    shiftVisibleRangeOnNewBar: true
                },
                localization: {
                    timeFormatter: (time) => {
                        // Convert timestamp to local time string
                        const date = new Date(time * 1000);
                        return date.toLocaleTimeString([], { 
                            hour: '2-digit', 
                            minute: '2-digit',
                            month: '2-digit',
                            day: '2-digit'
                        });
                    }
                }
            });

            // Create stochastic chart with local time configuration
            stochasticChart = LightweightCharts.createChart(stochasticContainer, {
                layout: {
                    backgroundColor: '#ffffff',
                    textColor: '#333',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
                width: stochasticContainer.clientWidth,
                height: stochasticContainer.clientHeight,
                rightPriceScale: {
                    scaleMargins: {
                        top: 0.1,
                        bottom: 0.1,
                    },
                    borderVisible: true,
                },
                timeScale: {
                    rightOffset: 0,
                    barSpacing: 6,
                    fixLeftEdge: false,
                    fixRightEdge: true,
                    lockVisibleTimeRangeOnResize: true,
                    timeVisible: true,
                    secondsVisible: true,
                    shiftVisibleRangeOnNewBar: true
                },
                localization: {
                    timeFormatter: (time) => {
                        // Convert timestamp to local time string
                        const date = new Date(time * 1000);
                        return date.toLocaleTimeString([], { 
                            hour: '2-digit', 
                            minute: '2-digit',
                            month: '2-digit',
                            day: '2-digit'
                        });
                    }
                }
            });

            // Add price series to price chart
            candleSeries = priceChart.addCandlestickSeries();
            
            // Add background areas to stochastic chart first (so they appear behind lines)
            createStochasticBackgrounds();
            
            // Initialize stochastic series in stochastic chart
            Object.keys(stochColors).forEach(key => {
                stochasticSeries[key] = stochasticChart.addLineSeries({
                    color: stochColors[key].color,
                    lineWidth: 2
                });
            });

            // Add reference lines for stochastic (90/15)
            const upperLine = stochasticChart.addLineSeries({
                color: '#FF0000',
                lineWidth: 2,
                lineStyle: 2,
                title: 'Overbought (90)'
            });
            
            const lowerLine = stochasticChart.addLineSeries({
                color: '#00FF00',
                lineWidth: 2,
                lineStyle: 2,
                title: 'Oversold (15)'
            });

            // Set reference line data using local time
            const now = Math.floor(Date.now() / 1000);
            const futureTime = now + 86400 * 30; // 30 days in future
            upperLine.setData([
                { time: now - 86400 * 30, value: 90 },
                { time: futureTime, value: 90 }
            ]);
            lowerLine.setData([
                { time: now - 86400 * 30, value: 15 },
                { time: futureTime, value: 15 }
            ]);

            // Sync time scales
            priceChart.timeScale().subscribeVisibleTimeRangeChange(() => {
                const timeRange = priceChart.timeScale().getVisibleRange();
                if (timeRange) {
                    stochasticChart.timeScale().setVisibleRange(timeRange);
                }
            });

            stochasticChart.timeScale().subscribeVisibleTimeRangeChange(() => {
                const timeRange = stochasticChart.timeScale().getVisibleRange();
                if (timeRange) {
                    priceChart.timeScale().setVisibleRange(timeRange);
                }
            });

            // Load stored alerts
            loadStoredAlerts();
            
            loadMultitimeframeData();
            setupAutoUpdate();
            updateStochasticLegend();
            setupIndicatorControls();
            
            document.getElementById('restore-price-chart-btn').addEventListener('click', () => {
                priceChart.timeScale().fitContent();
            });
            
            document.getElementById('restore-stochastic-chart-btn').addEventListener('click', () => {
                stochasticChart.timeScale().fitContent();
            });
            
            document.getElementById('initial-timestamp').textContent = new Date().toLocaleString();
        }
        
        function createStochasticBackgrounds() {
            // Create three area series for background colors
            
            // Overbought area (90-100) - Red background
            backgroundSeries.overbought = stochasticChart.addAreaSeries({
                topColor: 'rgba(255, 0, 0, 0.1)',
                bottomColor: 'rgba(255, 0, 0, 0.05)',
                lineColor: 'transparent',
                lineWidth: 0
            });
            
            // Neutral area (15-90) - Light gray background  
            backgroundSeries.neutral = stochasticChart.addAreaSeries({
                topColor: 'rgba(128, 128, 128, 0.05)',
                bottomColor: 'rgba(128, 128, 128, 0.02)',
                lineColor: 'transparent',
                lineWidth: 0
            });
            
            // Oversold area (0-15) - Green background
            backgroundSeries.oversold = stochasticChart.addAreaSeries({
                topColor: 'rgba(0, 255, 0, 0.1)',
                bottomColor: 'rgba(0, 255, 0, 0.05)',
                lineColor: 'transparent',
                lineWidth: 0
            });
        }
        
        function updateStochasticBackgrounds(timeData) {
            if (!timeData || timeData.length === 0) return;
            
            const now = Math.floor(Date.now() / 1000);
            const pastTime = now - 86400 * 30;
            const futureTime = now + 86400 * 30;
            
            // Set static background areas
            backgroundSeries.overbought.setData([
                { time: pastTime, value: 100 },
                { time: futureTime, value: 90 }
            ]);
            
            backgroundSeries.neutral.setData([
                { time: pastTime, value: 90 },
                { time: futureTime, value: 15 }
            ]);
            
            backgroundSeries.oversold.setData([
                { time: pastTime, value: 15 },
                { time: futureTime, value: 0 }
            ]);
        }
        
        function updateStochasticLegend() {
            const legend = document.getElementById('stochastic-legend');
            legend.innerHTML = '<div style="margin-bottom: 5px; font-weight: bold;">Stochastic Indicators:</div>';
            
            Object.keys(stochasticSeries).forEach(key => {
                if (stochasticSeries[key] && stochasticSeries[key].options().visible) {
                    const item = document.createElement('div');
                    item.className = 'stochastic-legend-item';
                    item.innerHTML = `
                        <span class="stochastic-legend-color" style="background:${stochColors[key].color}"></span>
                        <span>${stochColors[key].label}</span>
                    `;
                    legend.appendChild(item);
                }
            });
            
            // Add background zone legend
            const zoneInfo = document.createElement('div');
            zoneInfo.innerHTML = `
                <div style="margin-top: 8px; margin-bottom: 3px; font-weight: bold; font-size: 11px;">Background Zones:</div>
                <div style="font-size: 10px;">
                    <div style="margin: 2px 0;"><span style="background: rgba(255,0,0,0.2); padding: 1px 4px; margin-right: 4px;">&nbsp;</span>Overbought (â‰¥90)</div>
                    <div style="margin: 2px 0;"><span style="background: rgba(128,128,128,0.2); padding: 1px 4px; margin-right: 4px;">&nbsp;</span>Neutral (15-90)</div>
                    <div style="margin: 2px 0;"><span style="background: rgba(0,255,0,0.2); padding: 1px 4px; margin-right: 4px;">&nbsp;</span>Oversold (â‰¤15)</div>
                </div>
            `;
            legend.appendChild(zoneInfo);
        }

        // Heikin Ashi calculation
        function calculateHeikinAshi(candles) {
            const heikinAshi = [];
            
            for (let i = 0; i < candles.length; i++) {
                const current = candles[i];
                let ha = { time: current.time };
                
                if (i === 0) {
                    ha.open = (current.open + current.close) / 2;
                    ha.close = (current.open + current.high + current.low + current.close) / 4;
                    ha.high = current.high;
                    ha.low = current.low;
                } else {
                    const prev = heikinAshi[i - 1];
                    ha.open = (prev.open + prev.close) / 2;
                    ha.close = (current.open + current.high + current.low + current.close) / 4;
                    ha.high = Math.max(current.high, ha.open, ha.close);
                    ha.low = Math.min(current.low, ha.open, ha.close);
                }
                
                heikinAshi.push(ha);
            }
            
            return heikinAshi;
        }

        function calculateStochastic(candles, kPeriod = 14, dPeriod = 3, smoothK = 1) {
            const result = [];
            const kValues = [];
            const smoothedKValues = [];

            for (let i = 0; i < candles.length; i++) {
                if (i < kPeriod - 1) {
                    result.push({ time: candles[i].time, k: null, d: null });
                    continue;
                }

                let low = Infinity;
                let high = -Infinity;

                for (let j = i - kPeriod + 1; j <= i; j++) {
                    low = Math.min(low, candles[j].low);
                    high = Math.max(high, candles[j].high);
                }

                const currentClose = candles[i].close;
                const k = ((currentClose - low) / (high - low)) * 100;
                kValues.push(k);
                
                let smoothedK = k;
                if (smoothK > 1) {
                    if (kValues.length >= smoothK) {
                        const kSlice = kValues.slice(-smoothK);
                        smoothedK = kSlice.reduce((sum, val) => sum + val, 0) / smoothK;
                    } else {
                        smoothedK = null;
                    }
                }
                
                smoothedKValues.push(smoothedK);

                let d = null;
                if (smoothedKValues.length >= dPeriod) {
                    const dSlice = smoothedKValues.slice(-dPeriod);
                    d = dSlice.reduce((sum, val) => sum + val, 0) / dPeriod;
                }

                result.push({
                    time: candles[i].time,
                    k: smoothedK,
                    d: d,
                });
            }

            return result;
        }
        
        function calculateEMA(data, period, priceKey = 'close') {
            const k = 2 / (period + 1);
            const ema = [];
            
            let sum = 0;
            for (let i = 0; i < period && i < data.length; i++) {
                sum += data[i][priceKey];
                ema.push({ time: data[i].time, value: null });
            }
            
            if (data.length >= period) {
                ema[period-1] = { time: data[period-1].time, value: sum / period };
                
                for (let i = period; i < data.length; i++) {
                    const value = data[i][priceKey] * k + ema[i-1].value * (1 - k);
                    ema.push({ time: data[i].time, value: value });
                }
            }
            
            return ema;
        }

        async function loadTimeframeData(timeframe) {
            try {
                let candles;
                let stochastics;

                if (timeframe === '10m') {
                    // Fetch 5m data and aggregate to 10m
                    const limit = 400; // Fetch more 5m candles to aggregate into ~200 10m candles
                    const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${currentSymbol}&interval=5m&limit=${limit}`);
                    const data = await response.json();

                    // Aggregate 5m candles into 10m candles
                    candles = [];
                    for (let i = 0; i < data.length - 1; i += 2) {
                        const candle1 = data[i];
                        const candle2 = data[i + 1];
                        if (!candle2) break; // Ensure we have a pair

                        candles.push({
                            time: convertToLocalTime(candle1[0]), // Convert to local time
                            open: parseFloat(candle1[1]),
                            high: Math.max(parseFloat(candle1[2]), parseFloat(candle2[2])),
                            low: Math.min(parseFloat(candle1[3]), parseFloat(candle2[3])),
                            close: parseFloat(candle2[4]),
                            volume: parseFloat(candle1[5]) + parseFloat(candle2[5])
                        });
                    }
                } else {
                    // Standard timeframe fetching
                    const limit = ['1m', '5m'].includes(timeframe) ? 200 : 150;
                    const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${currentSymbol}&interval=${timeframe}&limit=${limit}`);
                    const data = await response.json();

                    candles = data.map(d => ({
                        time: convertToLocalTime(d[0]), // Convert to local time
                        open: parseFloat(d[1]),
                        high: parseFloat(d[2]),
                        low: parseFloat(d[3]),
                        close: parseFloat(d[4]),
                        volume: parseFloat(d[5])
                    }));
                }

                // Calculate all stochastics for this timeframe
                stochastics = {
                    fast: calculateStochastic(candles, 10, 3),
                    medium: calculateStochastic(candles, 14, 3),
                    slow: calculateStochastic(candles, 40, 4),
                    full: calculateStochastic(candles, 60, 3, 1)
                };

                multitimeframeData[timeframe] = {
                    candles: candles,
                    stochastics: stochastics,
                    lastUpdate: Date.now()
                };

                updateTimeframeStatus(timeframe, stochastics);
                checkTimeframeAlerts(timeframe, stochastics);
                
                return { candles, stochastics };
            } catch (error) {
                console.error(`Error loading ${timeframe} data:`, error);
                return null;
            }
        }
        
        function checkTimeframeAlerts(timeframe, stochastics) {
            const keys = ['fast', 'medium', 'slow', 'full'];
            const latest = {};
            
            // Get latest values for all stochastics
            keys.forEach(key => {
                const stochData = stochastics[key];
                latest[key] = stochData.length > 0 ? stochData[stochData.length - 1].d : null;
            });
            
            // Check if all are valid numbers
            const allValid = Object.values(latest).every(val => val !== null && !isNaN(val));
            if (!allValid) return;
            
            // Check for oversold condition (all <= 15)
            const allOversold = Object.values(latest).every(val => val <= 15);
            // Check for overbought condition (all >= 90)  
            const allOverbought = Object.values(latest).every(val => val >= 90);
            
            const alertKey = `${currentSymbol}_${timeframe}`;
            const previousState = timeframeAlertStates[alertKey];
            
            if (allOversold && previousState !== 'oversold') {
                timeframeAlertStates[alertKey] = 'oversold';
                const valuesStr = keys.map(key => `${key}: ${Math.round(latest[key])}`).join(', ');
                const message = `ðŸŸ¢ ${timeframe.toUpperCase()} OVERSOLD ALERT: All stochastics â‰¤15 (${valuesStr}) - Potential LONG setup for ${currentSymbol}`;
                addAlert(message, 'bullish', 'timeframe');
            } else if (allOverbought && previousState !== 'overbought') {
                timeframeAlertStates[alertKey] = 'overbought';
                const valuesStr = keys.map(key => `${key}: ${Math.round(latest[key])}`).join(', ');
                const message = `ðŸ”´ ${timeframe.toUpperCase()} OVERBOUGHT ALERT: All stochastics â‰¥90 (${valuesStr}) - Potential SHORT setup for ${currentSymbol}`;
                addAlert(message, 'bearish', 'timeframe');
            } else if (!allOversold && !allOverbought && previousState) {
                timeframeAlertStates[alertKey] = null; // Reset state when exiting extreme zones
            }
        }
        
        function updateTimeframeStatus(timeframe, stochastics) {
            const keys = ['fast', 'medium', 'slow', 'full'];
            keys.forEach(key => {
                const element = document.getElementById(`tf-${timeframe}-${key}`);
                if (element && stochastics[key].length > 0) {
                    const latestValue = stochastics[key][stochastics[key].length - 1].d;
                    if (latestValue !== null) {
                        const roundedValue = Math.round(latestValue);
                        element.textContent = `${key === 'medium' ? 'Med' : key.charAt(0).toUpperCase() + key.slice(1)}: ${roundedValue}`;
                        
                        // Update styling based on value
                        element.className = 'timeframe-status';
                        if (roundedValue <= 15) {
                            element.classList.add('tf-oversold');
                        } else if (roundedValue >= 90) {
                            element.classList.add('tf-overbought');
                        } else {
                            element.classList.add('tf-neutral');
                        }
                    }
                }
            });
        }
        
        async function loadMultitimeframeData() {
            const timeframes = ['1m', '5m', '10m', '15m', '30m', '1h'];
            
            // Load all timeframes in parallel
            const promises = timeframes.map(tf => loadTimeframeData(tf));
            await Promise.all(promises);
            
            // Load display data for current timeframe
            const displayData = multitimeframeData[currentTimeframe];
            if (displayData && displayData.candles) {
                currentCandles = displayData.candles;
                currentHeikinAshi = calculateHeikinAshi(currentCandles);
                
                // Set chart data
                const chartData = isHeikinAshi ? currentHeikinAshi : currentCandles;
                candleSeries.setData(chartData);
                
                // Update stochastic display
                Object.keys(stochasticSeries).forEach(key => {
                    if (displayData.stochastics[key]) {
                        const data = displayData.stochastics[key]
                            .filter(d => d.d !== null)
                            .map(d => ({ time: d.time, value: d.d }));
                        stochasticSeries[key].setData(data);
                    }
                });
                
                // Update background areas
                updateStochasticBackgrounds(displayData.stochastics.medium);
                
                // Calculate and display EMAs
                updateEMAs();
            }
            
            // Run confluence analysis
            analyzeConfluence();
        }
        
        function updateEMAs() {
            Object.keys(emaSeries).forEach(period => {
                const btn = document.querySelector(`.ema-btn[data-ema="${period}"]`);
                if (btn && btn.classList.contains('active')) {
                    if (!emaSeries[period]) {
                        emaSeries[period] = priceChart.addLineSeries({
                            color: getEMAColor(period),
                            lineWidth: 2,
                            title: `${period} EMA`,
                        });
                    }
                    const emaData = calculateEMA(currentCandles, parseInt(period));
                    emaSeries[period].setData(emaData);
                } else if (emaSeries[period]) {
                    priceChart.removeSeries(emaSeries[period]);
                    emaSeries[period] = null;
                }
            });
        }
        
        function getEMAColor(period) {
            const colors = {
                '20': '#F97316',
                '50': '#3B82F6',
                '100': '#10B981',
                '200': '#8B5CF6'
            };
            return colors[period] || '#333';
        }
        
        function addAlert(message, type, signalType = '') {
            const now = Date.now();
            if (now - lastAlertTime < 5000 && type !== 'info') return; // 5 second cooldown
            
            lastAlertTime = now;
            
            const alert = {
                timestamp: new Date().toLocaleTimeString(),
                message: message,
                type: type,
                signalType: signalType,
                symbol: currentSymbol,
                time: now
            };
            
            // Save to localStorage
            saveAlert(alert);
            
            // Add to UI
            addAlertToUI(message, type, signalType, alert.timestamp, false);
        }
        
        function addAlertToUI(message, type, signalType, timestamp, isStored) {
            const alertsContainer = document.getElementById('alerts-container');
            const alertDiv = document.createElement('div');
            
            let alertClass = 'p-3 rounded border-l-4 ';
            let iconClass = 'fas fa-info-circle ';
            
            switch(type) {
                case 'bullish':
                    if (signalType === 'confluence') {
                        alertClass += 'confluence-signal';
                    } else if (signalType === 'timeframe') {
                        alertClass += 'timeframe-alert';
                    } else {
                        alertClass += 'long-signal';
                    }
                    iconClass = 'fas fa-arrow-up text-green-500 ';
                    break;
                case 'bearish':
                    if (signalType === 'confluence') {
                        alertClass += 'confluence-signal';
                    } else if (signalType === 'timeframe') {
                        alertClass += 'timeframe-alert';
                    } else {
                        alertClass += 'short-signal';
                    }
                    iconClass = 'fas fa-arrow-down text-red-500 ';
                    break;
                default:
                    alertClass += 'bg-blue-50 border-blue-500';
                    iconClass = 'fas fa-info-circle text-blue-500 ';
            }
            
            alertDiv.className = alertClass;
            
            const badgeClass = isStored ? 'alert-stored' : 'alert-new';
            const badgeText = isStored ? 'STORED' : 'NEW';
            
            alertDiv.innerHTML = `
                <div class="flex items-center">
                    <i class="${iconClass}mr-2"></i>
                    <span class="text-sm font-medium">
                        [${timestamp}] ${message}
                    </span>
                    <span class="alert-badge ${badgeClass}">${badgeText}</span>
                </div>
            `;
            
            alertsContainer.insertBefore(alertDiv, alertsContainer.children[1]);
            
            // Keep only the last 20 alerts in UI
            while (alertsContainer.children.length > 21) {
                alertsContainer.removeChild(alertsContainer.lastChild);
            }
        }
        
        function updateConditionStatus(conditionId, isActive) {
            const element = document.getElementById(conditionId);
            if (!element) return;
            
            const icon = element.querySelector('.condition-icon');
            if (isActive) {
                icon.className = 'fas fa-check-circle text-green-500 mr-2 condition-icon signal-indicator';
            } else {
                icon.className = 'fas fa-circle text-gray-300 mr-2 condition-icon';
            }
        }
        
        function checkTimeframeCondition(timeframe) {
            const data = multitimeframeData[timeframe];
            if (!data || !data.stochastics) return { oversold: false, overbought: false };
            
            const stochs = data.stochastics;
            const latest = {
                fast: stochs.fast.length > 0 ? stochs.fast[stochs.fast.length - 1].d : null,
                medium: stochs.medium.length > 0 ? stochs.medium[stochs.medium.length - 1].d : null,
                slow: stochs.slow.length > 0 ? stochs.slow[stochs.slow.length - 1].d : null,
                full: stochs.full.length > 0 ? stochs.full[stochs.full.length - 1].d : null
            };
            
            const allOversold = latest.fast !== null && latest.medium !== null && latest.slow !== null && latest.full !== null &&
                               latest.fast <= 15 && latest.medium <= 15 && latest.slow <= 15 && latest.full <= 15;
            const allOverbought = latest.fast !== null && latest.medium !== null && latest.slow !== null && latest.full !== null &&
                                 latest.fast >= 90 && latest.medium >= 90 && latest.slow >= 90 && latest.full >= 90;
            
            return { oversold: allOversold, overbought: allOverbought };
        }
        
        function analyzeConfluence() {
            const timeframes = ['1m', '5m', '10m', '15m', '30m', '1h'];
            const confluenceGroups = [
                ['1m', '5m'],
                ['1m', '5m', '10m'],
                ['1m', '5m', '10m', '15m'],
                ['1m', '5m', '10m', '15m', '30m'],
                ['1m', '5m', '10m', '15m', '30m', '1h']
            ];
            
            // Check basic conditions (current timeframe)
            const currentCondition = checkTimeframeCondition(currentTimeframe);
            updateConditionStatus('basic-long-condition', currentCondition.oversold);
            updateConditionStatus('basic-short-condition', currentCondition.overbought);
            
            let maxConfluenceLevel = 0;
            let confluenceType = 'none';
            
            // Check each confluence level
            confluenceGroups.forEach((group, index) => {
                const level = index + 1;
                
                const oversoldCount = group.filter(tf => checkTimeframeCondition(tf).oversold).length;
                const overboughtCount = group.filter(tf => checkTimeframeCondition(tf).overbought).length;
                
                const isOversoldConfluence = oversoldCount === group.length;
                const isOverboughtConfluence = overboughtCount === group.length;
                
                const hasConfluence = isOversoldConfluence || isOverboughtConfluence;
                updateConditionStatus(`confluence-${level}-condition`, hasConfluence);
                
                if (hasConfluence) {
                    maxConfluenceLevel = level;
                    confluenceType = isOversoldConfluence ? 'long' : 'short';
                    
                    // Generate alert for confluence
                    const direction = isOversoldConfluence ? 'LONG' : 'SHORT';
                    const condition = isOversoldConfluence ? 'oversold (â‰¤15)' : 'overbought (â‰¥90)';
                    addAlert(
                        `âš¡ CONFLUENCE LEVEL ${level} ${direction}: All stochastic bands ${condition} across ${group.join(', ')} timeframes - Strong ${direction.toLowerCase()} signal for ${currentSymbol}!`,
                        isOversoldConfluence ? 'bullish' : 'bearish',
                        'confluence'
                    );
                }
            });
            
            // Update status displays
            document.getElementById('current-confluence-level').textContent = maxConfluenceLevel;
            document.getElementById('confluence-display').textContent = `${maxConfluenceLevel}/5`;
            document.getElementById('last-signal-type').textContent = confluenceType === 'none' ? 'None' : confluenceType.toUpperCase();
            
            // Update signal quality
            let quality = 'Weak';
            if (maxConfluenceLevel >= 4) quality = 'Very Strong';
            else if (maxConfluenceLevel >= 3) quality = 'Strong';
            else if (maxConfluenceLevel >= 2) quality = 'Moderate';
            else if (maxConfluenceLevel >= 1) quality = 'Fair';
            
            document.getElementById('signal-quality').textContent = quality;
            document.getElementById('signal-strength').textContent = quality;
        }
        
        function analyzeMarketTrend() {
            if (!emaSeries['200'] || currentCandles.length < 50) return;
            
            const latestPrice = currentCandles[currentCandles.length - 1].close;
            // Get EMA values manually from calculated data
            const ema200Data = calculateEMA(currentCandles, 200);
            const ema200 = ema200Data[ema200Data.length - 1]?.value;
            
            let trend = "Neutral";
            if (ema200 && latestPrice > ema200) {
                trend = "Uptrend";
            } else if (ema200 && latestPrice < ema200) {
                trend = "Downtrend";
            }
            
            document.getElementById('market-trend').textContent = trend;
        }
        
        function setupIndicatorControls() {
            // Stochastic toggles
            ['fast-10-3', 'medium-14-3', 'slow-40-4', 'full-60-3-1'].forEach(id => {
                document.getElementById(`stoch-${id}`).addEventListener('change', function() {
                    const key = id.replace('stoch-', '').replace('-10-3', '').replace('-14-3', '').replace('-40-4', '').replace('-60-3-1', '');
                    let actualKey;
                    if (id.includes('10-3')) actualKey = 'fast';
                    else if (id.includes('14-3')) actualKey = 'medium';
                    else if (id.includes('40-4')) actualKey = 'slow';
                    else if (id.includes('60-3-1')) actualKey = 'full';
                    
                    if (stochasticSeries[actualKey]) {
                        stochasticSeries[actualKey].applyOptions({ visible: this.checked });
                        updateStochasticLegend();
                    }
                });
            });
            
            // EMA toggles
            document.querySelectorAll('.ema-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    this.classList.toggle('active');
                    if (this.classList.contains('active')) {
                        this.classList.remove('bg-gray-300');
                        this.classList.add('bg-blue-500', 'text-white');
                    } else {
                        this.classList.remove('bg-blue-500', 'text-white');
                        this.classList.add('bg-gray-300');
                    }
                    updateEMAs();
                });
            });

            // Chart type toggles
            document.getElementById('regular-candles').addEventListener('click', function() {
                if (!this.classList.contains('active')) {
                    isHeikinAshi = false;
                    this.classList.add('active', 'bg-blue-500', 'text-white');
                    this.classList.remove('bg-gray-300');
                    document.getElementById('heikin-ashi').classList.remove('active', 'bg-blue-500', 'text-white');
                    document.getElementById('heikin-ashi').classList.add('bg-gray-300');
                    document.getElementById('current-chart-type').textContent = 'Regular';
                    
                    if (currentCandles.length > 0) {
                        candleSeries.setData(currentCandles);
                    }
                }
            });

            document.getElementById('heikin-ashi').addEventListener('click', function() {
                if (!this.classList.contains('active')) {
                    isHeikinAshi = true;
                    this.classList.add('active', 'bg-blue-500', 'text-white');
                    this.classList.remove('bg-gray-300');
                    document.getElementById('regular-candles').classList.remove('active', 'bg-blue-500', 'text-white');
                    document.getElementById('regular-candles').classList.add('bg-gray-300');
                    document.getElementById('current-chart-type').textContent = 'Heikin Ashi';
                    
                    if (currentHeikinAshi.length > 0) {
                        candleSeries.setData(currentHeikinAshi);
                    }
                }
            });

            // Clear alerts button
            document.getElementById('clear-alerts-btn').addEventListener('click', function() {
                if (confirm('Are you sure you want to clear all stored alerts?')) {
                    clearStoredAlerts();
                }
            });
        }

        function setupAutoUpdate() {
            if (updateInterval) clearInterval(updateInterval);
            
            // Update every 30 seconds for 1m/5m/10m, 60 seconds for others
            const frequency = ['1m', '5m', '10m'].includes(currentTimeframe) ? 30000 : 60000;
            
            updateInterval = setInterval(() => {
                loadMultitimeframeData();
                analyzeMarketTrend();
            }, frequency);
        }

        // Event listeners
        document.querySelectorAll('.timeframe-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.timeframe-btn').forEach(b => {
                    b.classList.remove('active', 'bg-blue-500', 'text-white');
                    b.classList.add('bg-gray-200', 'hover:bg-blue-500', 'hover:text-white');
                });
                this.classList.add('active', 'bg-blue-500', 'text-white');
                this.classList.remove('bg-gray-200', 'hover:bg-blue-500', 'hover:text-white');
                currentTimeframe = this.dataset.tf;
                loadMultitimeframeData(); // Reload with new display timeframe
            });
        });

        document.getElementById('crypto-selector').addEventListener('change', function() {
            currentSymbol = this.value;
            // Reset timeframe alert states for new symbol
            timeframeAlertStates = {};
            initCharts();
        });

        window.addEventListener('resize', function() {
            if (priceChart) {
                priceChart.applyOptions({ 
                    width: document.getElementById('price-chart-container').clientWidth,
                    height: document.getElementById('price-chart-container').clientHeight
                });
            }
            if (stochasticChart) {
                stochasticChart.applyOptions({ 
                    width: document.getElementById('stochastic-chart-container').clientWidth,
                    height: document.getElementById('stochastic-chart-container').clientHeight
                });
            }
        });

        // Initialize
        initCharts();
    </script>
</body>
</html>
